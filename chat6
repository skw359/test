import { a, defineData, ClientSchema } from '@aws-amplify/backend';
import { timeStamp } from 'console';

const schema = a.schema({
  Message: a
    .model({
      owner: a.string().required(),  
      receiver: a.string().required(),
      content: a.string().required(),
      timestamp: a.datetime().required(),
    })
    .authorization((allow) => [
      allow.authenticated(), // Allow any authenticated user to CRUD messages
    ])
    // Add indexes for efficient querying
    .secondaryIndexes((index) => [
      index('owner').sortKeys(['timestamp']),
      index('receiver').sortKeys(['timestamp']),
    ]),

  Chat: a //tables stores the unique chat id for each chat. Also stores the name of chat and when the initial chat was created
    .model({
      createdAt: a.datetime().required(),
      name: a.string()
    })
    .authorization((allow) => [
      allow.authenticated(), // Allow any authenticated user to CRUD messages
    ]),

  ChatUser: a // the join table between the chat table and the users in cognito. (what users are a part of what chats?)
    .model({
      username: a.string().required(),
      chatId: a.string().required(),
      timestamp: a.string().required(),
    })
    .authorization((allow) => [
      allow.authenticated(), // Allow any authenticated user to CRUD messages
    ])
    .secondaryIndexes((index) => [
      index('username'),
      index('chatId'),
    ]),

    ChatMessages: a // this table stores chats sent by users. It knows what chat room the message is from, when it was sent and who sent it
      .model({
        chatId: a.string().required(),
        sendername: a.string().required(),
        content: a.string().required(),
        timestamp: a.string().required(),
        messageType: a.string().default('text'), // 'text', 'meeting_invite', 'meeting_response'
      })
      .authorization((allow) => [
      allow.authenticated(), // Allow any authenticated user to CRUD messages
    ]),

    // New Calendar/Meeting related tables
    MeetingInvitation: a
      .model({
        invitationId: a.string().required(),
        chatId: a.string().required(),
        createdBy: a.string().required(),
        title: a.string().required(),
        description: a.string(),
        dateTime: a.datetime().required(),
        location: a.string(),
        status: a.string().required().default('pending'), // 'pending', 'accepted', 'declined', 'cancelled'
        createdAt: a.datetime().required(),
        updatedAt: a.datetime(),
      })
      .authorization((allow) => [
        allow.authenticated(),
      ])
      .secondaryIndexes((index) => [
        index('chatId').sortKeys(['dateTime']),
        index('createdBy').sortKeys(['createdAt']),
        index('invitationId'),
      ]),

    MeetingResponse: a
      .model({
        invitationId: a.string().required(),
        chatId: a.string().required(),
        username: a.string().required(),
        response: a.string().required(), // 'accepted', 'declined', 'tentative'
        respondedAt: a.datetime().required(),
      })
      .authorization((allow) => [
        allow.authenticated(),
      ])
      .secondaryIndexes((index) => [
        index('invitationId'),
        index('chatId').sortKeys(['respondedAt']),
        index('username').sortKeys(['respondedAt']),
      ]),

    Calendar: a // Store accepted meetings for easy calendar display
      .model({
        username: a.string().required(),
        invitationId: a.string().required(),
        chatId: a.string().required(),
        title: a.string().required(),
        description: a.string(),
        dateTime: a.datetime().required(),
        location: a.string(),
        createdBy: a.string().required(),
        addedAt: a.datetime().required(),
      })
      .authorization((allow) => [
        allow.authenticated(),
      ])
      .secondaryIndexes((index) => [
        index('username').sortKeys(['dateTime']),
        index('chatId').sortKeys(['dateTime']),
        index('invitationId'),
      ]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'userPool',
  },
});

/*== STEP 2 ===============================================================
Go to your frontend source code. From your client-side code, generate a
Data client to make CRUDL requests to your table. (THIS SNIPPET WILL ONLY
WORK IN THE FRONTEND CODE FILE.)

Using JavaScript or Next.js React Server Components, Middleware, Server
Actions or Pages Router? Review how to generate Data clients for those use
cases: https://docs.amplify.aws.gen2/build-a-backend/data/connect-to-API/
=========================================================================*/

/*
"use client"
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/amplify/data/resource";

const client = generateClient<Schema>() // use this Data client for CRUDL requests
*/

/*== STEP 3 ===============================================================
Fetch records from the database and use them in your frontend component.
(THIS SNIPPET WILL ONLY WORK IN THE FRONTEND CODE FILE.)
=========================================================================*/

/* For example, in a React component, you can use this snippet in your
  function's RETURN statement */
// const { data: todos } = await client.models.Todo.list()

// return <ul>{todos.map(todo => <li key={todo.id}>{todo.content}</li>)}</ul>

'use client';
 
import React, { useState, useEffect, useRef } from 'react';
import { getCurrentUser } from 'aws-amplify/auth';
import { generateClient } from 'aws-amplify/api';
import styles from '../styles/chat.module.css';
 
const client = generateClient();
 
function Chat() {
  const [currentUser, setCurrentUser] = useState('');
  const [recipientUsername, setRecipientUsername] = useState('');
  const [chatName, setChatName] = useState('')
  const [recipientInput, setRecipientInput] = useState('');
  const [messages, setMessages] = useState([]);
  const [messageInput, setMessageInput] = useState('');
  const messagesEndRef = useRef(null);
  const [loading, setloading] = useState(false);
  const [currChatId, setcurrChatId] = useState('');
  const [chats, setChats] = useState([]);
  
  // Calendar/Meeting states
  const [showMeetingModal, setShowMeetingModal] = useState(false);
  const [meetingForm, setMeetingForm] = useState({
    title: '',
    description: '',
    dateTime: '',
    location: ''
  });

  useEffect(() => {
    const fetchCurrentUser = async () => {
      try {
        const user = await getCurrentUser();
        console.log(user)
        setCurrentUser(user.username || user.signInDetails?.loginId || '');
       
      } catch (err) {
        console.log(err);
      }
    };
    fetchCurrentUser();
  }, []);
 
  useEffect(() => { // load in chat rooms
        if (!currentUser) return;
 
        const sub = client.models.ChatUser.observeQuery({
            filter: { username: { eq: currentUser } },
            sort: { field: 'timestamp', direction: 'desc' }
        }).subscribe({
            next: ({ items }) => {
                console.log('ChatUser items updated:', items);
 
                const enrich = async (items) => {
 
                  const enrichedChats = await Promise.all(items.map(async (chatUser) => {
                  try {
                    const chatRecord = await client.models.Chat.get({ id: chatUser.chatId });
                    console.log(chatRecord)
                    return {
                      ...chatUser,
                      chatName: chatRecord?.data.name || 'Unnamed Chat',
                    };
                  } catch (error) {
                    console.warn(`Failed to fetch chat for chatId: ${chatUser.chatId}`, error);
                    return { ...chatUser, chatName: 'Unknown' };
                  }
                  }));
                  console.log("new chats", enrichedChats)
                  setChats(enrichedChats);  // or handle as needed
                  setloading(false);
 
 
                }
               
                enrich(items)    
            },
            error: (error) => {
                console.warn('Subscription error:', error);
                setloading(false);
            }
        });
 
        return () => sub.unsubscribe();
  }, [currentUser]);
 
  useEffect(() => { // get all the messages associated with a chat
      if (!currChatId) return;
 
      const sub = client.models.ChatMessages.observeQuery({
          filter: { chatId: { eq: currChatId } },
          sort: { field: 'timestamp', direction: 'desc' }
      }).subscribe({
          next: ({ items }) => {
              console.log("Chat messages updated: ",items)
 
              const sortedMessages = [...items].sort((a, b) =>
                  new Date(a.timestamp) - new Date(b.timestamp)
                  );
              setMessages(sortedMessages);
          },
              error: (error) => {
              console.error("Error loading messages:", error);
          }
      });
 
      return () => sub.unsubscribe();
  }, [currChatId]);  
 
 
    // members is a list of usernames in the chat
  const createChat = async () => {
      try{
          if (!currentUser && !chatName && !recipientInput){
              console.error("Could not get user")
              return;
          }
          const newChat = await client.models.Chat.create({
              createdAt: new Date().toISOString(),
              name:chatName || 'New Chat'
          });
 
          const uniqueMembers = Array.from(new Set([recipientInput, currentUser]));
 
          for (const member of uniqueMembers) {
              const newCU = await client.models.ChatUser.create({
              username: member,
              chatId: newChat.data.id,
              timestamp: new Date().toISOString(),
              });
 
          }
 
         
          setRecipientInput('')
          setChatName('')
 
          setcurrChatId(newChat.data.chatId)
      }catch(error){
          console.error("Error creating chat:", error);
      }
  }
   
 
  const createMessage = async (content, messageType = 'text')=>{
    try{
        if (!currentUser ){
            console.error("Could not get user")
            return;
        }
        if (!currChatId){
            console.error("could not get chatroom")
            return;
        }
 
        const newMessage = await client.models.ChatMessages.create({
            chatId: currChatId,
            sendername: currentUser,
            content: content,
            timestamp: new Date().toISOString(),
            messageType: messageType,
        });

        // Clear message input if it's a regular text message
        if (messageType === 'text') {
            setMessageInput('');
        }
       
    }catch(error){
        console.error("Error creating message:", error);
    }
  }

  // Meeting/Calendar functions
  const createMeetingInvitation = async () => {
    try {
      if (!currentUser || !currChatId) {
        console.error("Missing user or chat information");
        return;
      }

      if (!meetingForm.title || !meetingForm.dateTime) {
        alert("Please fill in at least the title and date/time");
        return;
      }

      // Generate unique invitation ID
      const invitationId = `meeting_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

      // Create meeting invitation record
      await client.models.MeetingInvitation.create({
        invitationId: invitationId,
        chatId: currChatId,
        createdBy: currentUser,
        title: meetingForm.title,
        description: meetingForm.description,
        dateTime: new Date(meetingForm.dateTime).toISOString(),
        location: meetingForm.location,
        status: 'pending',
        createdAt: new Date().toISOString(),
      });

      // Create meeting invitation message
      const meetingMessage = {
        type: 'meeting_invite',
        meeting: {
          invitationId: invitationId,
          title: meetingForm.title,
          description: meetingForm.description,
          dateTime: new Date(meetingForm.dateTime).toISOString(),
          location: meetingForm.location,
          createdBy: currentUser,
          status: 'pending'
        }
      };

      await createMessage(JSON.stringify(meetingMessage), 'meeting_invite');

      // Reset form and close modal
      setMeetingForm({
        title: '',
        description: '',
        dateTime: '',
        location: ''
      });
      setShowMeetingModal(false);

    } catch (error) {
      console.error("Error creating meeting invitation:", error);
    }
  };

  const handleMeetingResponse = async (invitationId, response) => {
    try {
      if (!currentUser || !currChatId) {
        console.error("Missing user or chat information");
        return;
      }

      // Record the response
      await client.models.MeetingResponse.create({
        invitationId: invitationId,
        chatId: currChatId,
        username: currentUser,
        response: response,
        respondedAt: new Date().toISOString(),
      });

      // If accepted, add to calendar
      if (response === 'accepted') {
        // Get the original meeting invitation
        const meetingInvite = await client.models.MeetingInvitation.get({ 
          invitationId: invitationId 
        });

        if (meetingInvite.data) {
          await client.models.Calendar.create({
            username: currentUser,
            invitationId: invitationId,
            chatId: currChatId,
            title: meetingInvite.data.title,
            description: meetingInvite.data.description,
            dateTime: meetingInvite.data.dateTime,
            location: meetingInvite.data.location,
            createdBy: meetingInvite.data.createdBy,
            addedAt: new Date().toISOString(),
          });
        }
      }

      // Send response message
      const responseMessage = {
        type: 'meeting_response',
        meeting: {
          invitationId: invitationId,
          response: response,
          respondedBy: currentUser,
          respondedAt: new Date().toISOString()
        }
      };

      await createMessage(JSON.stringify(responseMessage), 'meeting_response');

    } catch (error) {
      console.error("Error handling meeting response:", error);
    }
  };

  const renderMessage = (msg) => {
    try {
      // Try to parse as JSON for special message types
      const content = JSON.parse(msg.content);
      
      if (content.type === 'meeting_invite') {
        const meeting = content.meeting;
        const isCurrentUserSender = msg.sendername === currentUser;
        
        return (
          <div className={`${styles.meetingInvite} ${isCurrentUserSender ? styles.sentInvite : styles.receivedInvite}`}>
            <div className={styles.meetingHeader}>
              <span className={styles.meetingIcon}>üìÖ</span>
              <span className={styles.meetingTitle}>{meeting.title}</span>
            </div>
            <div className={styles.meetingDetails}>
              <div className={styles.meetingDateTime}>
                {new Date(meeting.dateTime).toLocaleString()}
              </div>
              {meeting.location && (
                <div className={styles.meetingLocation}>üìç {meeting.location}</div>
              )}
              {meeting.description && (
                <div className={styles.meetingDescription}>{meeting.description}</div>
              )}
              <div className={styles.meetingCreator}>
                Created by: {meeting.createdBy}
              </div>
            </div>
            {!isCurrentUserSender && meeting.status === 'pending' && (
              <div className={styles.meetingActions}>
                <button 
                  className={styles.acceptButton}
                  onClick={() => handleMeetingResponse(meeting.invitationId, 'accepted')}
                >
                  Accept
                </button>
                <button 
                  className={styles.declineButton}
                  onClick={() => handleMeetingResponse(meeting.invitationId, 'declined')}
                >
                  Decline
                </button>
              </div>
            )}
            {meeting.status !== 'pending' && (
              <div className={`${styles.meetingStatus} ${styles[meeting.status]}`}>
                {meeting.status === 'accepted' ? '‚úÖ Accepted' : '‚ùå Declined'}
              </div>
            )}
          </div>
        );
      }
      
      if (content.type === 'meeting_response') {
        const response = content.meeting;
        return (
          <div className={styles.meetingResponse}>
            <span className={styles.responseIcon}>
              {response.response === 'accepted' ? '‚úÖ' : '‚ùå'}
            </span>
            <span className={styles.responseText}>
              {response.respondedBy} {response.response} the meeting invitation
            </span>
          </div>
        );
      }
      
    } catch (e) {
      // Not a JSON message, render as regular text
    }
    
    // Regular text message
    return <div className={styles.messageContent}>{msg.content}</div>;
  };

  const formatTime = (timestamp) => {
    if (!timestamp) return '';
    const date = new Date(timestamp);
    const now = new Date();
    const diff = now - date;
    const mins = Math.floor(diff / 60000);
    const hours = Math.floor(diff / 3600000);
    const days = Math.floor(diff / 86400000);
    if (mins < 1) return 'now';
    if (mins < 60) return `${mins}m`;
    if (hours < 24) return `${hours}h`;
    if (days < 7) return `${days}d`;
    return date.toLocaleDateString();
  };
 
  const getInitials = (name) => name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
 
  if (!currentUser) return <div className={styles.loading}>Loading user...</div>;
 
  return (
    <div className={styles.chatContainer}>
      <div className={styles.sidebar}>
        <div className={styles.sidebarHeader}>
          <h2 className={styles.title}>Chats</h2>
          <input
              type="text"
              value={chatName}
              onChange={e => setChatName(e.target.value)}
              placeholder="Enter New Chat Name"
              className={styles.input}
            />
          <div className={styles.newChatInput}>
            <input
              type="text"
              value={recipientInput}
              onChange={e => setRecipientInput(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && createChat()}
              placeholder="Start new chat..."
              className={styles.input}
            />
           
            <button onClick={()=> {
              const members = recipientInput // this is code for if there are multiple users, (not really supported now)
                    .split(',')
                    .map((name) => name.trim())
                    .filter(Boolean);
                if (members.length === 0) return;
                createChat(members);
 
            }} className={styles.addButton}>+</button>
          </div>
        </div>
        <div className={styles.chatList}>
          {chats.length === 0 ? (
            <div className={styles.noChats}>No recent chats</div>
          ) : (
            chats.map(chat => {
              //const lastMsg = lastMessages[chat];
              const isActive = chat.username === recipientUsername;
              return (
                <div
                  key={chat.chatId}
                  className={`${styles.chatItem} ${isActive ? styles.activeChat : ''}`}
                  onClick={() => setcurrChatId(chat.chatId)}
                >
                  <div className={styles.avatar}>{getInitials(chat.chatId)}</div>
                  <div className={styles.chatInfo}>
                   
                    <div className={styles.chatTop}>
                     
                     <span className={styles.chatName}>{chat.chatName}</span>
                      {/*lastMsg && <span className={styles.chatTime}>{formatTime(lastMsg.timestamp)}</span> */}
                    </div>
                    {/*lastMsg && (
                      <div className={styles.chatPreview}>
                        {lastMsg.owner === currentUser ? 'You: ' : ''}
                        {lastMsg.content}
                      </div>