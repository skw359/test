'use client';
 
import React, { useState, useEffect, useRef } from 'react';
import { fetchUserAttributes, getCurrentUser } from 'aws-amplify/auth';
import { generateClient } from 'aws-amplify/api';
import styles from '../styles/chat.module.css';
 
const client = generateClient();

// ‚ú® NEW: Dedicated component to render a single meeting invitation message.
// This allows us to use React hooks (useState, useEffect) to subscribe to
// real-time status updates for just this one message without breaking hook rules.
const MeetingInviteMessage = ({ meeting, currentUser, prefferedDictionary, onRespond }) => {
  const [latestMeeting, setLatestMeeting] = useState(null);
  const isRecipient = meeting.createdBy !== currentUser;

  // This effect subscribes to the specific meeting invitation in the database.
  // If the status changes (e.g., from 'pending' to 'accepted'), this component will re-render.
  useEffect(() => {
    if (!meeting.id) return; // Don't run if the message is malformed

    const subscription = client.models.MeetingInvitation.observeQuery({ 
      filter: { id: { eq: meeting.id } } 
    }).subscribe({
      next: (data) => {
        if (data.items.length > 0) {
          setLatestMeeting(data.items[0]);
        }
      },
      error: (error) => console.error(`Subscription error for meeting ${meeting.id}:`, error)
    });

    // Clean up the subscription when the component is no longer on screen
    return () => subscription.unsubscribe();
  }, [meeting.id]); // Re-run only if the meeting ID changes

  // Use the real-time status if we have it, otherwise fallback to the original message status
  const currentStatus = latestMeeting?.status || meeting.status;

  return (
    <div className={styles.meetingInvite}>
      <div className={styles.meetingHeader}>
        <span className={styles.meetingIcon}>üìÖ</span>
        <span className={styles.meetingTitle}>{meeting.title}</span>
      </div>
      <div className={styles.meetingDetails}>
        <div className={styles.meetingDateTime}>
          üóìÔ∏è {new Date(meeting.dateTime).toLocaleString(undefined, {
            dateStyle: 'medium',
            timeStyle: 'short'
          })}
        </div>
        {meeting.location && (
          <div className={styles.meetingLocation}>üìç {meeting.location}</div>
        )}
        {meeting.description && (
          <div className={styles.meetingDescription}>"{meeting.description}"</div>
        )}
        <div className={styles.meetingCreator}>
          Invited by: {prefferedDictionary[meeting.createdBy] || meeting.createdBy}
        </div>
      </div>
      
      {/* Show action buttons ONLY if the current user is the recipient AND the meeting is pending */}
      {isRecipient && currentStatus === 'pending' && (
        <div className={styles.meetingActions}>
          <button 
            className={styles.acceptButton}
            onClick={() => onRespond(meeting.id, 'accepted')}
          >
            Accept
          </button>
          <button 
            className={styles.declineButton}
            onClick={() => onRespond(meeting.id, 'declined')}
          >
            Decline
          </button>
        </div>
      )}
      
      {/* Show the final status badge if the meeting is no longer pending */}
      {currentStatus !== 'pending' && (
        <div className={`${styles.meetingStatus} ${styles[currentStatus]}`}>
          {currentStatus === 'accepted' ? '‚úÖ Accepted' : '‚ùå Declined'}
        </div>
      )}
    </div>
  );
};


// Main Chat Component
function Chat() {
  const [currentUser, setCurrentUser] = useState('');
  const [recipientUsername, setRecipientUsername] = useState('');
  const [chatName, setChatName] = useState('')
  const [recipientInput, setRecipientInput] = useState('');
  const [messages, setMessages] = useState([]);
  const [messageInput, setMessageInput] = useState('');
  const messagesEndRef = useRef(null);
  const [loading, setLoading] = useState(false);
  const [currChatId, setcurrChatId] = useState('');
  const [chats, setChats] = useState([]);
  const [prefferedDictionary, setPrefferedDictionary ] = useState({})

  // calendar/mtg states
  const [showMeetingModal, setShowMeetingModal] = useState(false);
  const [meetingForm, setMeetingForm] = useState({
    title: '',
    description: '',
    dateTime: '',
    location: ''
  });

  useEffect(() => {
    const fetchCurrentUser = async () => {
      try {
        const user = await getCurrentUser();
        setCurrentUser(user.username || user.signInDetails?.loginId || '');
        const attributes = await fetchUserAttributes();
        setPrefferedDictionary(prev => ({
          ...prev,
          [user.username] : attributes.preferred_username
        }));
      } catch (err) {
        console.log(err);
      }
    };
    fetchCurrentUser();
  }, []);
 
  useEffect(() => {
    if (!currentUser) return;
    const sub = client.models.ChatUser.observeQuery({
      filter: { username: { eq: currentUser } },
      sort: { field: 'timestamp', direction: 'desc' }
    }).subscribe({
      next: ({ items }) => {
        const enrich = async (items) => {
          const enrichedChats = await Promise.all(items.map(async (chatUser) => {
            try {
              const chatRecords = await client.models.ChatUser.list({ filter:{ chatId: {eq: chatUser.chatId,}} });
              let recipientUser = '';
              chatRecords.data.forEach((chatRecord) => {
                if (chatRecord.username !== currentUser) {
                  recipientUser = chatRecord.username;
                }
              });
              const ProfileRecords = await client.models.UserProfile.list({ filter:{ userId: {eq: recipientUser,}} });
              const name = ProfileRecords.data[0]?.prefUser || recipientUser;
              setPrefferedDictionary(prev => ({ ...prev, [recipientUser]: name }));
              return { ...chatUser, chatName: `Chat with ${name}` };
            } catch (error) {
              console.warn(`Failed to enrich chat for chatId: ${chatUser.chatId}`, error);
              return { ...chatUser, chatName: 'Unknown Chat' };
            }
          }));
          setChats(enrichedChats);
          setLoading(false);
        };
        enrich(items);
      },
      error: (error) => {
        console.warn('Subscription error:', error);
        setLoading(false);
      }
    });
    return () => sub.unsubscribe();
  }, [currentUser]);
 
  useEffect(() => {
    if (!currChatId) return;
    const sub = client.models.ChatMessages.observeQuery({
      filter: { chatId: { eq: currChatId } },
      sort: { field: 'timestamp', direction: 'desc' }
    }).subscribe({
      next: ({ items }) => {
        const sortedMessages = [...items].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
        setMessages(sortedMessages);
      },
      error: (error) => console.error(error)
    });
    return () => sub.unsubscribe();
  }, [currChatId]);  

  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);
 
  const createChat = async () => {
    try {
      if (!currentUser || !recipientInput) return;
      setLoading(true);
      const newChat = await client.models.Chat.create({
        createdAt: new Date().toISOString(),
        name: chatName || `Chat with ${recipientInput}`
      });
      const uniqueMembers = Array.from(new Set([recipientInput, currentUser]));
      for (const member of uniqueMembers) {
        await client.models.ChatUser.create({
          username: member,
          chatId: newChat.data.id,
          timestamp: new Date().toISOString(),
        });
      }
      setRecipientInput('');
      setChatName('');
      setcurrChatId(newChat.data.id);
      setLoading(false);
    } catch (error) {
      console.error(error);
      setLoading(false);
    }
  };
   
  const createMessage = async (content, messageType = 'text') => {
    try {
      if (!currentUser || !currChatId || !content.trim()) return;
      await client.models.ChatMessages.create({
        chatId: currChatId,
        sendername: currentUser,
        content: content,
        timestamp: new Date().toISOString(),
        messageType: messageType,
      });
      if (messageType === 'text') {
        setMessageInput('');
      }
    } catch (error) {
      console.error(error);
    }
  };

  // ‚ú® UPDATED: Function to create the meeting invitation in the database and send the message.
  const createMeetingInvitation = async () => {
    try {
      if (!currentUser || !currChatId || !meetingForm.title || !meetingForm.dateTime) {
        alert("Title and Date & Time are required for a meeting.");
        return;
      }
      const chatUsersRecords = await client.models.ChatUser.list({
        filter: { chatId: { eq: currChatId } }
      });
      const recipient = chatUsersRecords.data.find(user => user.username !== currentUser)?.username;
      if (!recipient) {
        console.error("Error fetching recipient");
        return;
      }
      const newMeetingInvite = await client.models.MeetingInvitation.create({
        chatId: currChatId,
        createdBy: currentUser,
        title: meetingForm.title,
        description: meetingForm.description || '',
        dateTime: new Date(meetingForm.dateTime).toISOString(),
        location: meetingForm.location || '',
        status: 'pending',
        createdAt: new Date().toISOString(),
        invited: recipient
      });
      const meetingMessage = {
        type: 'meeting_invite',
        meeting: {
          id: newMeetingInvite.data.id, // CRITICAL: Pass the database ID in the message
          title: meetingForm.title,
          description: meetingForm.description,
          dateTime: new Date(meetingForm.dateTime).toISOString(),
          location: meetingForm.location,
          createdBy: currentUser,
          status: 'pending'
        }
      };
      await createMessage(JSON.stringify(meetingMessage), 'meeting_invite');
      setMeetingForm({ title: '', description: '', dateTime: '', location: '' });
      setShowMeetingModal(false);
    } catch (error) {
      console.error("Error creating meeting invitation:", error);
      alert("Failed to create meeting invitation.");
    }
  };

  // ‚ú® UPDATED: Function to handle responding to a meeting invitation.
  const meetingResponse = async (invitationId, response) => {
    try {
      if (!currentUser || !invitationId) return;
      // 1. Update the database record. This is the source of truth.
      await client.models.MeetingInvitation.update({
        id: invitationId,
        status: response,
        updatedAt: new Date().toISOString(),
      });
      // 2. Send a confirmation message to the chat for a nice UX.
      const responseMessage = {
        type: 'meeting_response',
        meeting: {
          invitationId: invitationId,
          response: response,
          respondedBy: currentUser,
        }
      };
      await createMessage(JSON.stringify(responseMessage), 'meeting_response');
    } catch (error) {
      console.error("Error responding to meeting:", error);
      alert("Failed to respond to meeting.");
    }
  };

  // ‚ú® UPDATED: This function now acts as a "dispatcher", choosing what to render.
  const renderMessage = (msg) => {
    try {
      const content = JSON.parse(msg.content);
      
      if (content.type === 'meeting_invite') {
        // If it's a meeting invite, render our special component.
        return (
          <MeetingInviteMessage
            meeting={content.meeting}
            currentUser={currentUser}
            prefferedDictionary={prefferedDictionary}
            onRespond={meetingResponse} // Pass the handler function as a prop
          />
        );
      }
      
      if (content.type === 'meeting_response') {
        const response = content.meeting;
        const isAccepted = response.response === 'accepted';
        return (
          <div className={styles.meetingResponse}>
            <span className={styles.responseIcon}>{isAccepted ? '‚úÖ' : '‚ùå'}</span>
            <span className={styles.responseText}>
              {prefferedDictionary[response.respondedBy] || response.respondedBy} 
              {isAccepted ? ' accepted' : ' declined'} the invitation.
            </span>
          </div>
        );
      }
      
    } catch (e) {
      // If it's not valid JSON, it's a plain text message.
    }
    return msg.content;
  };

  const getInitials = (name) => {
    if (!name) return '??';
    return name.split(' ').map(n => n[0]).join('').toUpperCase().slice(0, 2);
  };

  const getMinDateTime = () => {
    const now = new Date();
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    return now.toISOString().slice(0,16);
  };
 
  if (!currentUser) return <div className={styles.loading}>Loading user...</div>;
 
  return (
    <div className={styles.chatContainer}>
      <div className={styles.sidebar}>
        <div className={styles.sidebarHeader}>
          <h2 className={styles.title}>Chats</h2>
          <div className={styles.newChatInput}>
            <input
              type="text"
              value={recipientInput}
              onChange={e => setRecipientInput(e.target.value)}
              onKeyDown={e => e.key === 'Enter' && createChat()}
              placeholder="Start new chat..."
              className={styles.input}
            />
            <button onClick={createChat} className={styles.addButton} disabled={loading}>
              {loading ? '...' : '+'}
            </button>
          </div>
        </div>
        <div className={styles.chatList}>
          {chats.length === 0 ? (
            <div className={styles.noChats}>No recent chats</div>
          ) : (
            chats.map(chat => (
              <div
                key={chat.chatId}
                className={`${styles.chatItem} ${chat.chatId === currChatId ? styles.activeChat : ''}`}
                onClick={() => setcurrChatId(chat.chatId)}
              >
                <div className={styles.avatar}>{getInitials(chat.chatName)}</div>
                <div className={styles.chatInfo}>
                  <div className={styles.chatTop}>
                    <span className={styles.chatName}>{chat.chatName}</span>
                  </div>
                </div>
              </div>
            ))
          )}
        </div>
      </div>
      <div className={styles.chatWindow}>
        {!currChatId ? (
          <div className={styles.welcome}>
            <h3>Welcome to Velocity Messaging</h3>
            <p>Select a chat or start a new conversation.</p>
          </div>
        ) : (
          <>
            <div className={styles.chatHeader}>
              <div className={styles.avatar}>{getInitials(chats.find(chat => chat.chatId === currChatId)?.chatName || 'C')}</div>
              <h3>{chats.find(chat => chat.chatId === currChatId)?.chatName || 'Chat'}</h3>
            </div>
            <div className={styles.messages}>
              {messages.map((msg) => (
                <div
                  key={msg.id}
                  className={`${styles.messageWrapper} ${msg.sendername === currentUser ? styles.messageSent : styles.messageReceived}`}
                >
                  <div className={styles.messageContent}>{renderMessage(msg)}</div>
                  <div className={styles.messageTime}>
                    {new Date(msg.timestamp || msg.createdAt || '').toLocaleTimeString([], {
                      hour: '2-digit', minute: '2-digit'
                    })}
                  </div>
                </div>
              ))}
              <div ref={messagesEndRef}></div>
            </div>
            <div className={styles.messageInputWrapper}>
              <button
                onClick={() => setShowMeetingModal(true)}
                className={styles.calendarButton}
                title="Create meeting"
              >
                üìÖ
              </button>
              <input
                value={messageInput}
                onChange={e => setMessageInput(e.target.value)}
                onKeyDown={e => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    createMessage(messageInput);
                  }
                }}
                placeholder="Write a message..."
                className={styles.messageInput}
              />
              <button
                onClick={() => createMessage(messageInput)}
                disabled={!messageInput.trim()}
                className={styles.sendButton}
              >
                Send
              </button>
            </div>
          </>
        )}
      </div>

      {showMeetingModal && (
        <div className={styles.modalOverlay} onClick={() => setShowMeetingModal(false)}>
          <div className={styles.modal} onClick={(e) => e.stopPropagation()}>
            <div className={styles.modalHeader}>
              <h3>Create Meeting Invitation</h3>
              <button className={styles.closeButton} onClick={() => setShowMeetingModal(false)}>√ó</button>
            </div>
            <div className={styles.modalContent}>
              <div className={styles.formGroup}>
                <label htmlFor="meetingTitle">Title *</label>
                <input id="meetingTitle" type="text" value={meetingForm.title} onChange={(e) => setMeetingForm({...meetingForm, title: e.target.value})} placeholder="Meeting title" className={styles.formInput}/>
              </div>
              <div className={styles.formGroup}>
                <label htmlFor="meetingDateTime">Date & Time *</label>
                <input id="meetingDateTime" type="datetime-local" value={meetingForm.dateTime} onChange={(e) => setMeetingForm({...meetingForm, dateTime: e.target.value})} min={getMinDateTime()} className={styles.formInput}/>
              </div>
              <div className={styles.formGroup}>
                <label htmlFor="meetingLocation">Location</label>
                <input id="meetingLocation" type="text" value={meetingForm.location} onChange={(e) => setMeetingForm({...meetingForm, location: e.target.value})} placeholder="e.g., Zoom Link or Room 404" className={styles.formInput}/>
              </div>
              <div className={styles.formGroup}>
                <label htmlFor="meetingDescription">Description</label>
                <textarea id="meetingDescription" value={meetingForm.description} onChange={(e) => setMeetingForm({...meetingForm, description: e.target.value})} placeholder="e.g., Project kickoff agenda" className={styles.formTextarea} rows="3"/>
              </div>
            </div>
            <div className={styles.modalActions}>
              <button className={styles.cancelButton} onClick={() => setShowMeetingModal(false)}>Cancel</button>
              <button className={styles.createButton} onClick={createMeetingInvitation} disabled={!meetingForm.title || !meetingForm.dateTime}>Create Invitation</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

export default Chat;
